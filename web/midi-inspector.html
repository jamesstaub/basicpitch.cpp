<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI File Inspector</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .inspector { border: 1px solid #ccc; padding: 20px; margin: 20px 0; border-radius: 5px; }
        .hex-dump { font-family: monospace; background: #f5f5f5; padding: 10px; border-radius: 3px; overflow-x: auto; white-space: pre; }
        .midi-info { background: #e8f4f8; padding: 10px; border-radius: 3px; margin: 10px 0; }
        .error { background: #ffe6e6; color: #d00; padding: 10px; border-radius: 3px; }
        .success { background: #e6ffe6; color: #060; padding: 10px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>MIDI File Inspector</h1>
    
    <div class="inspector">
        <h2>Upload MIDI File</h2>
        <input type="file" id="midi-upload" accept=".mid,.midi">
        <button id="inspect-btn">Inspect MIDI File</button>
    </div>

    <div id="results"></div>

    <script>
        const fileInput = document.getElementById('midi-upload');
        const inspectBtn = document.getElementById('inspect-btn');
        const resultsDiv = document.getElementById('results');

        function bytesToHex(bytes) {
            return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join(' ');
        }

        function bytesToString(bytes) {
            return Array.from(bytes, byte => (byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.')).join('');
        }

        function createHexDump(data, maxBytes = 512) {
            const bytes = new Uint8Array(data);
            const displayBytes = bytes.slice(0, maxBytes);
            let output = '';
            for (let i = 0; i < displayBytes.length; i += 16) {
                const offset = i.toString(16).padStart(8, '0');
                const chunk = displayBytes.slice(i, i + 16);
                const hex = bytesToHex(chunk).padEnd(47, ' ');
                const ascii = bytesToString(chunk);
                output += `${offset}: ${hex} |${ascii}|\n`;
            }
            if (bytes.length > maxBytes) output += `\n... (showing first ${maxBytes} of ${bytes.length} bytes)`;
            return output;
        }

        function parseMIDIHeader(data) {
            const view = new DataView(data);
            const header = {};
            const headerChunk = String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3));
            if (headerChunk !== 'MThd') throw new Error(`Invalid MIDI header: ${headerChunk}`);
            header.headerChunk = headerChunk;
            header.headerLength = view.getUint32(4);
            header.format = view.getUint16(8);
            header.numTracks = view.getUint16(10);
            header.division = view.getUint16(12);
            if (header.division & 0x8000) {
                header.timingFormat = 'SMPTE';
                header.smpteFormat = (header.division >> 8) & 0x7F;
                header.ticksPerFrame = header.division & 0xFF;
            } else {
                header.timingFormat = 'Ticks per quarter note';
                header.ticksPerQuarterNote = header.division;
            }
            return header;
        }

        function findTracks(data) {
            const view = new DataView(data);
            const tracks = [];
            let offset = 14;
            while (offset < data.byteLength - 8) {
                const trackChunk = String.fromCharCode(view.getUint8(offset), view.getUint8(offset + 1), view.getUint8(offset + 2), view.getUint8(offset + 3));
                if (trackChunk === 'MTrk') {
                    const trackLength = view.getUint32(offset + 4);
                    tracks.push({ offset: offset, length: trackLength, dataStart: offset + 8, dataEnd: offset + 8 + trackLength });
                    offset += 8 + trackLength;
                } else offset++;
            }
            return tracks;
        }

        function parseTempo(trackData) {
            const view = new DataView(trackData.buffer, trackData.byteOffset, trackData.byteLength);
            let offset = 0;
            while (offset < view.byteLength - 3) {
                // Look for Meta Event: 0xFF 0x51 (Set Tempo)
                if (view.getUint8(offset) === 0x00) offset++; // Skip delta time
                else if (view.getUint8(offset) === 0xFF && view.getUint8(offset + 1) === 0x51) {
                    const length = view.getUint8(offset + 2);
                    if (length === 3) {
                        const tempo = (view.getUint8(offset + 3) << 16) | (view.getUint8(offset + 4) << 8) | view.getUint8(offset + 5);
                        const bpm = 60000000 / tempo;
                        return bpm.toFixed(2);
                    }
                }
                offset++;
            }
            return null;
        }

        function inspectMIDI(file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const data = event.target.result;
                const fileSize = data.byteLength;
                let html = `<div class="inspector">`;
                html += `<h2>File Information</h2>`;
                html += `<p><strong>Filename:</strong> ${file.name}</p>`;
                html += `<p><strong>File Size:</strong> ${fileSize} bytes</p>`;

                try {
                    const header = parseMIDIHeader(data);
                    html += `<div class="success">✓ Valid MIDI file detected</div>`;
                    html += `<div class="midi-info"><h3>MIDI Header Information</h3>`;
                    html += `<p><strong>Header Chunk:</strong> ${header.headerChunk}</p>`;
                    html += `<p><strong>Header Length:</strong> ${header.headerLength} bytes</p>`;
                    html += `<p><strong>Format:</strong> ${header.format}</p>`;
                    html += `<p><strong>Number of Tracks:</strong> ${header.numTracks}</p>`;
                    html += `<p><strong>Timing Format:</strong> ${header.timingFormat}</p>`;
                    if (header.ticksPerQuarterNote) html += `<p><strong>Ticks per Quarter Note:</strong> ${header.ticksPerQuarterNote}</p>`;
                    html += `</div>`;

                    const tracks = findTracks(data);
                    html += `<div class="midi-info"><h3>Track Information</h3>`;
                    html += `<p><strong>Tracks Found:</strong> ${tracks.length}</p>`;

                    tracks.forEach((track, index) => {
                        const trackData = new Uint8Array(data, track.dataStart, track.length);
                        const tempo = parseTempo(trackData);
                        console.log(tempo);
                        html += `<p><strong>Track ${index + 1}:</strong> ${track.length} bytes (offset: ${track.offset})`;
                        if (tempo) html += ` — Tempo: ${tempo} BPM`;
                        html += `</p>`;
                    });

                    html += `</div>`;
                    if (tracks.length !== header.numTracks) html += `<div class="error">⚠ Warning: Header says ${header.numTracks} tracks, but found ${tracks.length}</div>`;
                } catch (error) {
                    html += `<div class="error">✗ Error parsing MIDI file: ${error.message}</div>`;
                }

                html += `<h3>Raw Data (Hex Dump)</h3>`;
                html += `<div class="hex-dump">${createHexDump(data)}</div>`;
                html += `</div>`;
                resultsDiv.innerHTML = html;
            };
            reader.readAsArrayBuffer(file);
        }

        inspectBtn.addEventListener('click', () => {
            const file = fileInput.files[0];
            if (file) inspectMIDI(file);
            else resultsDiv.innerHTML = '<div class="error">Please select a MIDI file first</div>';
        });
    </script>
</body>
</html>
